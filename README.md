## 프로젝트 소개
이 프로젝트는 Spring Data JPA와 QueryDSL 환경에서 발생하는 N+1 문제를 해결하고, 다양한 쿼리 최적화 기법의 성능을 객관적으로 검증하기 위해 작성되었습니다.
특히, User와 UserPhoto 간의 @OneToMany 관계에서 발생하는 지연 로딩(Lazy Loading) 문제를 중심으로 BatchSize와 Fetch Join의 효과를 측정하고 비교하는 데 중점을 두었습니다.

## 테스트 진행 배경
기존 프로젝트에서 대규모 데이터 조회 시 심각한 성능 저하가 발생했습니다. 주요 원인은 연관 관계를 지연 로딩할 때 발생하는 N+1 문제였습니다. 이를 해결하기 위해 여러 최적화 기법을 적용했고, 본 테스트를 통해 그 효과를 수치적으로 확인하고자 했습니다.
문제 식별: User 목록을 조회한 후, 각 User의 UserPhoto 목록에 접근할 때마다 추가적인 SELECT 쿼리가 발생하는 N+1 문제를 확인했습니다.
최적화 목표: 쿼리 수를 최소화하고, 대량의 데이터 조회 시 발생하는 응답 시간을 단축합니다.
주요 검증 대상:
- @BatchSize: User 엔티티의 userPhotos 컬렉션에 @BatchSize(size = 10)을 적용하여 N개의 쿼리를 N/10개로 줄이는 효과를 검증합니다.
- Fetch Join + 정렬 문제: (이 부분은 명시적인 문제가 발생하지 않았지만) Fetch Join과 정렬을 함께 사용할 때 발생할 수 있는 잠재적 성능 저하 및 오류 가능성을 확인합니다.

## 테스트 환경 및 방법
환경: Spring Boot 3.x, Spring Data JPA, H2 Database (인메모리 DB)
테스트 데이터: N+1 문제 재현을 위해 100명의 더미 User와 각 User당 3개의 UserPhoto를 생성했습니다.
테스트 방법:
- 지연 로딩 테스트: 최적화 기법을 적용하지 않은 상태에서 user.getUserPhotos()를 호출하여 1 + N 쿼리가 발생하는 것을 확인하고, 이때의 실행 시간을 측정합니다.
- @BatchSize 최적화 테스트: @BatchSize가 적용된 상태에서 동일한 로직을 실행하여 쿼리 수가 1 + (N / BatchSize)로 줄어드는 것을 확인하고, 실행 시간을 비교합니다.
- 성능 지표: Hibernate의 Statistics 기능을 활용하여 실행된 쿼리 수를 정확히 측정하고, **System.nanoTime()**을 이용해 메서드 **실행 시간(속도)**을 측정했습니다.

## 결론 및 성과
이 테스트를 통해 @BatchSize 어노테이션이 대량의 연관 관계 조회에서 쿼리 수를 극적으로 줄여 성능을 효과적으로 최적화함을 증명했습니다.
비록 테스트 환경에서는 체감하기 어려운 작은 시간 차이였지만, 이는 서비스 규모가 확장되었을 때 발생할 수 있는 치명적인 성능 저하를 사전에 방지하는 중요한 해결책임을 확인했습니다.
